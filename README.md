Explanation of Cryptographic Has API.md
==============

Cryptographic Hash Function
--------------
+과거에는 데이터베이스에 저장된 비밀번호와 사용자가 입력한 값을 직접 비교하는 프로세스가 일반적
+현재에는 각종 사이버 범죄와 해킹으로 정보 유출 사건이 증가함에 따라 민감한 정보를 암호화
+암호화하는 대표적인 방법: 암호화 해시 함수(Cryptographic Hash Function)

Digest
-------------
+입력된 비밀번호 -> 암호화 해시 함수 -> 다이제스트에 저장
+다이제스트: 해시함수를 통해 생성된 암호화된 메시지
+해시함수: 입력값을 문자와 숫자를 임의로 나열한 일정한 길이의 다이제스트로 전환해줌
>일반적으로 사용자가 입력한 비밀번호는 암호화 해시 함수를 거쳐 다이제스트(Digest)의 형태로 저장됩니다. 여기서 다이제스트란, 해시 함수라는 수학적인 연산을 통해 생성된 암호화된 메시지를 의미합니다. 해시 함수는 임의의 비밀번호 입력값을 문자와 숫자를 임의로 나열한 일정한 길이의 다이제스트로 전환합니다. 기존에 데이터베이스에 저장된 다이제스트와 비교해서 일치하면 서비스에 로그인할 수 있습니다.

Characteristic of Cryptographic Hash Function
-----------
+단방향
+비밀번호 -> 암호화 해시 함수 -> 다이제스트 (o)
+비밀번호 <- 암호화 해시 함수 <- 다이제스트 (x)
>암호화 해시 함수의 특징은 바로 '단방향'이라는 것입니다. 비밀번호를 알면 다이제스트를 바로 연산할 수는 있지만, 다이제스트만으로는 비밀번호를 역추적하는 것이 거의 불가능합니다. 이와 같은 이유로 비밀번호를 데이터베이스에 저장하는 대신, 다이제스트를 저장하는 것이 보편화되고 있습니다. 국내에서는 '개인정보보호법'과 '정보통신망 이용촉진 및 정보보호 등에 관한 법률'을 통해 비밀번호, 주민등록번호와 같은 개인정보를 반드시 암호화해야 한다고 규정하고 있기도 합니다.

Kind of Cryptographic Hash Function
--------------
>잘 알려진 암호화 해시 함수에는 MD5, SHA-1, SHA-256 등이 있습니다. 최근에는 HAS-150이나 MD5, SHA-1는 보안성이 취약하다는 이유로 잘 사용되지 않고 있습니다. 일반적으로 많이 사용되는 컴퓨터로도 초당 56억 개의 다이제스트를 대입할 수 있는데요, 상대적으로 다이제스트 길이가 짧은 이들 함수에서는 암호화된 비밀번호를 해독하는 데 걸리는 시간이 생각보다 길지 않기 때문입니다.
>그렇지만 지금 KISA에서 권고하고 있는 SHA-256 등 다른 해시 함수가 완벽한 대안이라는 의미는 아닙니다. 본래 해시 함수는 짧은 시간에 데이터를 효율적으로 검색하기 위해 만들어졌습니다. 해시 함수의 빠른 데이터 처리 속도를 역이용하는 해커들은 GPU를 장착한 기기로 병렬 처리해 초당 수억 건의 다이제스트를 비교하는 무력화 기술이라든가 모든 입력 가능한 비밀번호와 다이제스트를 미리 생성해놓고 무작위로 공격하는 딕셔너리 공격을 단행하고 있습니다. 결국, 시간 싸움인 셈이죠.

Stretching & Salt
-----------
![hash_function03](https://user-images.githubusercontent.com/43162506/49694907-b484ad80-fbd5-11e8-97ef-944af811cfbb.png)
스트레칭은 복잡한 연산을 반복 적용하는 것을 의미합니다. 즉, 암호화 해시 함수를 수천 번에서 혹은 수만 번을 반복하는 것이죠. 이는 무작위 공격으로 비밀번호를 추측하는 데 많은 시간이 소요되도록 하는 방법으로, 반복 횟수를 늘리는 것만으로도 방어력을 효과적으로 높일 수 있다는 장점이 있습니다.

![Alt text](/C:\Users\user\Desktop\Hallym\2018-2\OpenSourceSW\Assignment/to/hash_function02(1).png)
솔트는 32비트 이상의 문자열로, 사용자마다 서로 다른 값이 부여됩니다. 위 그림처럼 비밀번호 앞 또는 뒤에 이 문자열을 추가하여 다이제스트를 생성하는 것을 소금치기, 즉 솔팅(Salting)이라고 합니다. 만일 100명의 사용자가 “ITWorld08” 이라는 비밀번호를 보유했다고 하더라도 솔팅 작업을 거치면 100개의 서로 다른 다이제스트를 생성할 수 있습니다. 동일한 비밀번호에 대해 항상 동일한 다이제스트가 생성하는 해시 함수의 문제점을 보완해주는 것이죠.

이와 같은 2가지 조치를 취하면 고사양 GPU를 탑재한 컴퓨터를 갖추고도 초당 30건의 다이제스트만 겨우 대입해볼 수 있습니다. 그렇지 않을 경우에는 10억 단위로도 처리가능한 데 말이죠. 아스 테크니카(Ars Technica)의 보도에 따르면, 30건도 무리라며 초당 10회 정도 테스트할 수 있을 것이라고 추정됩니다.

이와 같은 이유로 다이제스트나 솔트값이 해킹되더라도 당장 위험하지는 않습니다. 해커들은 “digest080808”과 일치하는 비밀번호를 찾기 위해 수십억 건의 비밀번호 테스트를 진행해야 하기 때문입니다. 그렇지만 암호화 해시 함수 자체가 일정한 규칙에 따라 다이제스트를 생성하는 점을 생각해봤을 때 비밀번호 역추적 가능성도 열어놔야 하는 것이죠. 무엇보다 중요한 것은 해커가 손쉽게 추적할 수 없는 복잡한 비밀번호를 설정하는 습관을 들이는 것입니다. 최소 6개월마다 한 번씩 비밀번호를 바꾸는 것도 좋은 방법입니다. 
